{
  "version": 1,
  "scripts": [
    {
      "metadata": {
        "uuid": "81412ebd-1902-4298-b156-2969ea775c0b",
        "title": "Index Project Files",
        "last_modified": "2025-03-11T19:53:05.293167",
        "last_executed": "2025-03-11T19:53:12.004742"
      },
      "current": {
        "code": "\"\"\"\nindex_files.py - Indexes files in a Binary Ninja project for searching\n\nThis script creates a searchable index of files in the current Binary Ninja project\nusing the Whoosh library.\n\"\"\"\nimport os\nimport sys\nfrom typing import List, Optional\n\ntool = {\n    \"name\": \"index_project_files\",\n    \"description\": \"Creates a searchable index of the project files\",\n    \"parameters\": {\n        \"properties\": {\n            \"extensions\": {\n                \"type\": \"string\",\n                \"description\": \"Comma-separated list of file extensions to index (e.g., '.c,.h,.py'). Default: index all files.\"\n            },\n            \"force_reindex\": {\n                \"type\": \"boolean\",\n                \"description\": \"Force recreation of the index even if it already exists\"\n            }\n        },\n        \"required\": [\"extensions\"]\n    }\n}\n\ndef ensure_whoosh_installed() -> bool:\n    \"\"\"\n    Checks if the Whoosh library is installed and attempts to install it if not.\n    \n    Returns:\n        bool: True if Whoosh is available after function execution, False otherwise\n    \"\"\"\n    try:\n        import whoosh\n        log_info(\"Whoosh is already installed\")\n        return True\n    except ImportError:\n        log_info(\"Whoosh not found, attempting to install...\")\n \n        try:\n            import pip\n            pip.main(['install', 'whoosh'])\n        except:\n            try:\n                # For newer pip versions\n                import pip._internal\n                pip._internal.main(['install', 'whoosh'])\n            except Exception as e:\n                log_error(f\"Pip installation failed: {e}\")\n                return False\n        \n        # Check if installation succeeded\n        try:\n            import whoosh\n            log_info(\"Whoosh successfully installed\")\n            return True\n        except ImportError:\n            log_error(\"Failed to install Whoosh\")\n            return False\n\ndef create_index_directory(project_path: str) -> str:\n    \"\"\"\n    Creates the directory for the Whoosh index within the project.\n    \n    Args:\n        project_path: Path to the project\n        \n    Returns:\n        str: Path to the index directory\n    \"\"\"\n    index_dir = os.path.join(project_path, 'whoosh_index')\n    if not os.path.exists(index_dir):\n        os.makedirs(index_dir)\n        log_info(f\"Created index directory at {index_dir}\")\n    else:\n        log_info(f\"Using existing index directory at {index_dir}\")\n    return index_dir\n\ndef should_index_file(file_path: str, extensions: Optional[List[str]] = None) -> bool:\n    \"\"\"\n    Determines if a file should be indexed based on its extension.\n    \n    Args:\n        file_path: Path to the file\n        extensions: List of extensions to include (with dot, e.g. ['.txt', '.py'])\n        \n    Returns:\n        bool: True if the file should be indexed, False otherwise\n    \"\"\"\n    if not extensions:\n        return True\n    \n    return any(file_path.lower().endswith(ext.lower()) for ext in extensions)\n\ndef index_files(project, extensions: Optional[List[str]] = None, force_reindex: bool = False) -> bool:\n    \"\"\"\n    Creates an index of the files in the project.\n    \n    Args:\n        project: Binary Ninja project object\n        extensions: List of file extensions to include\n        force_reindex: Whether to force reindexing even if index exists\n        \n    Returns:\n        bool: True if indexing was successful, False otherwise\n    \"\"\"\n    try:\n        from whoosh.index import create_in, open_dir, exists_in\n        from whoosh.fields import Schema, TEXT, ID\n        \n        project_path = project.path\n        index_dir = create_index_directory(project_path)\n        \n        # Define the schema\n        schema = Schema(path=ID(stored=True), content=TEXT(stored=True))\n        \n        # Check if index already exists\n        if exists_in(index_dir) and not force_reindex:\n            log_info(\"Index already exists. Use force_reindex=True to recreate.\")\n            return True\n        \n        # Create the index\n        ix = create_in(index_dir, schema)\n        log_info(\"Created new search index\")\n        \n        # Index the files\n        writer = ix.writer()\n        total_files = len(project.files)\n        indexed_count = 0\n        skipped_count = 0\n        error_count = 0\n        \n        log_info(f\"Indexing {total_files} files...\")\n        \n        for i, f in enumerate(project.files):\n            if i % 100 == 0 and i > 0:\n                log_info(f\"Processed {i}/{total_files} files...\")\n                \n            if not f.exists_on_disk:\n                skipped_count += 1\n                continue\n                \n            if not should_index_file(f.name, extensions):\n                skipped_count += 1\n                continue\n            \n            try:\n                with open(f.path_on_disk, \"r\", encoding=\"utf-8\", errors=\"replace\") as file:\n                    content = file.read()\n                    writer.add_document(path=f.id, content=content)\n                    indexed_count += 1\n            except Exception as e:\n                log_warn(f\"Error indexing {f.name}: {e}\")\n                error_count += 1\n        \n        writer.commit()\n        log_info(f\"Indexing complete. Indexed: {indexed_count}, Skipped: {skipped_count}, Errors: {error_count}\")\n        return True\n        \n    except Exception as e:\n        log_error(f\"Error during indexing: {e}\")\n        return False\n\ndef main():\n    \"\"\"Main function to run the indexing process\"\"\"\n    try:\n        # `get_tool_arguments` returns a dict containing the arguments\n        args = get_tool_arguments(tool)\n    except Exception as e:\n        import traceback\n        traceback.print_exc(e)\n        log_error(f\"Error parsing arguments: {e}\")\n        return 1\n    \n    # Ensure Whoosh is installed\n    if not ensure_whoosh_installed():\n        log_error(\"Whoosh library is required but could not be installed.\")\n        return 1\n    \n    # Parse extensions\n    extensions = None\n    if \"extensions\" in args and args[\"extensions\"]:\n        extensions = [ext.strip() for ext in args[\"extensions\"].split(\",\")]\n        log_info(f\"Will index files with extensions: {extensions}\")\n    else:\n        log_info(\"Will index all files\")\n    \n    # Get force_reindex flag\n    force_reindex = args.get(\"force_reindex\", False)\n    if force_reindex:\n        log_info(\"Force reindex enabled - will create a new index\")\n    \n    # Get the current project\n    try:\n        proj = current_project\n    except NameError:\n        log_error(\"This script must be run within Binary Ninja\")\n        return 1\n    \n    # Index the files\n    success = index_files(proj, extensions, force_reindex)\n    \n    if success:\n        log_info(\"Indexing completed successfully\")\n        return 0\n    else:\n        log_error(\"Indexing failed\")\n        return 1\n\nmain()\n",
        "llm_op_specifications": []
      }
    },
    {
      "metadata": {
        "uuid": "deb0b7ab-17a5-4da5-8c13-876820bc5353",
        "title": "Search Project Files",
        "last_modified": "2025-03-20T14:31:53.762319",
        "last_executed": "2025-03-20T14:31:55.767713"
      },
      "current": {
        "code": "\"\"\"\nSearches indexed files in a Binary Ninja project\n\"\"\"\nimport os\nimport sys\nfrom typing import List, Dict, Any, Optional\n\ntool = {\n    \"name\": \"search_project_files\",\n    \"description\": \"Searches and returns content from the project files\",\n    \"parameters\": {\n        \"properties\": {\n            \"query\": {\n                \"type\": \"string\",\n                \"description\": \"Query keywords\"\n            },\n            \"max_results\": {\n                \"type\": \"integer\",\n                \"description\": \"Maximum number of matching documents to return (0 for all)\",\n                \"default\": 0\n            },\n            \"context_size\": {\n                \"type\": \"integer\",\n                \"description\": \"Number of characters to show around each match\",\n                \"default\": 100\n            },\n            \"max_snippets\": {\n                \"type\": \"integer\",\n                \"description\": \"Maximum number of context snippets to display per document\",\n                \"default\": 3\n            }\n        },\n        \"required\": [\"query\"]\n    }\n}\n\ndef ensure_whoosh_installed() -> bool:\n    \"\"\"\n    Checks if the Whoosh library is installed and attempts to install it if not.\n    \n    Returns:\n        bool: True if Whoosh is available after function execution, False otherwise\n    \"\"\"\n    try:\n        import whoosh\n        log_info(\"Whoosh is already installed\")\n        return True\n    except ImportError:\n        log_info(\"Whoosh not found, attempting to install...\")\n \n        try:\n            import pip\n            pip.main(['install', 'whoosh'])\n        except:\n            try:\n                # For newer pip versions\n                import pip._internal\n                pip._internal.main(['install', 'whoosh'])\n            except Exception as e:\n                log_error(f\"Pip installation failed: {e}\")\n                return False\n        \n        # Check if installation succeeded\n        try:\n            import whoosh\n            log_info(\"Whoosh successfully installed\")\n            return True\n        except ImportError:\n            log_error(\"Failed to install Whoosh\")\n            return False\n\ndef get_index_directory(project_path: str) -> str:\n    \"\"\"\n    Gets the path to the Whoosh index directory.\n    \n    Args:\n        project_path: Path to the project\n        \n    Returns:\n        str: Path to the index directory\n    \"\"\"\n    return os.path.join(project_path, 'whoosh_index')\n\ndef search_index(\n    index_dir: str, \n    query_str: str, \n    max_results: Optional[int] = 0, \n    context_size: int = 100,\n    max_snippets: int = 3\n) -> List[Dict[str, Any]]:\n    \"\"\"\n    Searches the index with the given query.\n    \n    Args:\n        index_dir: Path to the index directory\n        query_str: Search query string\n        max_results: Maximum number of results to return (0 for all)\n        context_size: Number of characters to show around matches\n        max_snippets: Maximum number of context snippets per result\n        \n    Returns:\n        List of dictionaries containing the search results\n    \"\"\"\n    try:\n        from whoosh.index import open_dir\n        from whoosh.qparser import QueryParser\n        from whoosh.highlight import ContextFragmenter, NullFormatter\n        \n        # Open the index\n        ix = open_dir(index_dir)\n        \n        # Set up the search\n        results_list = []\n        with ix.searcher() as searcher:\n            # Create a query parser\n            query = QueryParser(\"content\", ix.schema).parse(query_str)\n            \n            # Search\n            limit = None if max_results == 0 else max_results\n            results = searcher.search(query, limit=limit)\n            \n            # Set up the highlighter\n            surround = context_size // 2\n            results.highlighter.formatter = NullFormatter()  # No markup\n            results.highlighter.fragmenter = ContextFragmenter(maxchars=context_size, surround=surround)\n            \n            # Process results\n            for hit in results:\n                # Get the context snippets (text around matches)\n                context = hit.highlights(\"content\", top=max_snippets, minscore=0)\n                \n                # Add to results list\n                results_list.append({\n                    \"path\": hit[\"path\"],\n                    \"context\": context,\n                    \"score\": hit.score\n                })\n        \n        return results_list\n        \n    except Exception as e:\n        log_error(f\"Error during search: {e}\")\n        return []\n\ndef format_results(results: List[Dict[str, Any]]) -> str:\n    \"\"\"\n    Formats the search results for display.\n    \n    Args:\n        results: List of search result dictionaries\n        \n    Returns:\n        str: Formatted results string\n    \"\"\"\n    if not results:\n        return \"No results found.\"\n    \n    output = []\n    output.append(f\"Found {len(results)} match{'es' if len(results) != 1 else ''}:\")\n    output.append(\"\")\n    \n    for i, result in enumerate(results, 1):\n        output.append(f\"{i}. File ID: {result['path']}\")\n        output.append(f\"   Score: {result['score']:.2f}\")\n        output.append(\"\")\n        \n        # Add context with line breaks for readability\n        context_lines = result[\"context\"].split(\"\\n\")\n        for line in context_lines:\n            if line.strip():\n                output.append(f\"   {line}\")\n        \n        output.append(\"---\")\n    \n    return \"\\n\".join(output)\n\ndef main() -> int:\n    \"\"\"\n    Main function to run the search.\n    \n    Returns:\n        int: Exit code (0 for success, 1 for error)\n    \"\"\"\n    try:\n        # `get_tool_arguments` returns a dict containing the arguments\n        args = get_tool_arguments(tool)\n    except Exception as e:\n        log_error(f\"Error parsing arguments: {e}\")\n        return 1\n    \n    # Ensure Whoosh is installed\n    if not ensure_whoosh_installed():\n        log_error(\"Whoosh library is required but could not be installed.\")\n        return 1\n    \n    # Get arguments\n    query = args[\"query\"]\n    max_results = args.get(\"max_results\", 0)\n    context_size = args.get(\"context_size\", 100)\n    max_snippets = args.get(\"max_snippets\", 3)\n    \n    log_info(f\"Searching for: {query}\")\n    \n    # Get the current project\n    try:\n        proj = current_project\n    except NameError:\n        log_error(\"This script must be run within Binary Ninja\")\n        return 1\n        \n    if proj is None:\n        print(\"This script must be run with an open Binary Ninja project.\")\n        return 1\n    \n    # Get the index directory\n    index_dir = get_index_directory(proj.path)\n    \n    # Check if index exists\n    if not os.path.exists(index_dir):\n        log_error(\"Index does not exist. Run index_files.py first.\")\n        return 1\n    \n    # Search the index\n    results = search_index(index_dir, query, max_results, context_size, max_snippets)\n    \n    # Format and display results\n    formatted_results = format_results(results)\n    print(formatted_results)\n    \n    return 0\n\nmain()",
        "llm_op_specifications": []
      }
    }
  ]
}